<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <script src="translations.js"></script>
	<script src="quotes.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">

    <script src="https://cdn.jsdelivr.net/npm/emoji-mart@latest/dist/browser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>

<body>
	<div id="welcome-screen">
		<div class="lang-selector-home">
			<select id="lang-select-home" onchange="applyLanguage(this.value)">
				<option value="fr">FranÃ§ais ðŸ‡«ðŸ‡·</option>
				<option value="en">English ðŸ‡¬ðŸ‡§</option>
				<option value="zh">ä¸­æ–‡ ðŸ‡¨ðŸ‡³</option>
			</select>
		</div>

		<div class="welcome-card">
			<h1 id="txt-welcome-title">Bienvenue</h1>
			
			<div id="daily-quote-container">
				<span id="quote-intro" style="font-weight: bold; font-size: 0.9em; color: #3498db;"></span>
				<p id="quote-text">--</p>
			</div>

			<button id="enter-chat-btn" onclick="startSecurityProcess()">AccÃ©der au Chat SÃ©curisÃ©</button>
		</div>
	</div>
    <div id="chat-container">
        <div id="chat-header">
            <div style="font-weight: bold;" id="txt-header-title"></div>

			<div class="clocks-container" style="display: flex; gap: 20px; align-items: center; padding: 10px;">
				<div class="clock-unit">
					<div class="analog-clock" id="them-analog">
						<div class="hand hour"></div>
						<div class="hand minute"></div>
						<div class="center-dot"></div>
					</div>
					<div id="them-city-name" style="margin-top: 4px;">--</div>
				</div>
				<div class="clock-unit">
					<div class="analog-clock" id="me-analog">
						<div class="hand hour"></div>
						<div class="hand minute"></div>
						<div class="center-dot"></div>
					</div>
					<div id="me-city-name" style="margin-top: 4px;">--</div>
				</div>
			</div>
			
            <div class="header-right">
                <a href="/cgu" target="_blank" id="txt-view-cgu"></a>
                <button id="theme-toggle" style="cursor:pointer; border:none; background:none; font-size: 1.2rem;">ðŸŒ™</button>
                <select id="lang-select" style="cursor: pointer; margin-left: 10px;">
                    <option value="fr">FranÃ§ais ðŸ‡«ðŸ‡·</option>
                    <option value="en">English ðŸ‡¬ðŸ‡§</option>
                    <option value="zh">ä¸­æ–‡ ðŸ‡¨ðŸ‡³</option>
                </select>
            </div>
			
        </div>
        <ul id="messages"></ul>
        <div id="typing-indicator"></div>
        <form id="form">
            <button type="button" id="emoji-btn">ðŸ˜€</button>
            <label for="file-input" style="cursor:pointer; font-size: 1.5em; padding: 0 10px;">ðŸ“Ž</label>
            <input type="file" id="file-input" accept="image/*" style="display:none;">

            <textarea id="input" placeholder="Ã‰crivez un message..." rows="1"></textarea>
            <button type="submit">Envoyer</button>
        </form>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        var socket = io();
        var chatContainer = document.getElementById('chat-container');
        var messages = document.getElementById('messages');
        var form = document.getElementById('form');
        var input = document.getElementById('input');
        var typingIndicator = document.getElementById('typing-indicator');
        var SECRET_KEY = "";
        var myPseudo = "";
        var typingTimeout;
    
        // --- 1. SÃ‰CURITÃ‰ D'ACCÃˆS ---
		// --- DÃ‰TECTION DE LA LANGUE POUR LES PROMPTS ---

		// --- 1. SÃ‰CURITÃ‰ D'ACCÃˆS TRADUITE ---
		function startSecurityProcess() {			
			var lang = localStorage.getItem('preferred-lang') || (navigator.language.startsWith('fr') ? 'fr' : 'en');
			var t = translations[lang] || translations['fr'];

			var pass = prompt(t.prompt_password);

			if (pass === "TCPAJ") {
				SECRET_KEY = prompt(t.prompt_secret_key);
				
				if (!SECRET_KEY) {
					alert(t.alert_key_mandatory);
					return;
				}

				myPseudo = prompt(t.prompt_pseudo) || "Anonyme";

				// --- C'EST ICI QU'ON LANCE LA CONNEXION ---
				socket = io(); // On initialise la connexion seulement maintenant !

				// On dÃ©finit les Ã©couteurs AVANT de faire le join
				setupSocketListeners(); 

				document.getElementById('welcome-screen').style.display = 'none';
				document.getElementById('chat-container').style.display = 'flex';

				const myTZ = Intl.DateTimeFormat().resolvedOptions().timeZone;
				socket.emit('join', myPseudo, myTZ);
				
			} else {
				alert(t.alert_access_denied);
			}
		}
    
        // --- 2. FONCTION DE FORMATEUR DE DATE (29 Dec 18:05) ---
        function getNowFormatted() {
            var now = new Date();
            var options = { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' };
            // 'en-GB' donne le format Jour Mois Heure sans virgules inutiles
            return now.toLocaleDateString('en-GB', options).replace(',', '');
        }
    
        // --- 3. FONCTION D'AFFICHAGE DES MESSAGES ---
		function addMessage(data, side) {
			var item = document.createElement('li');
			item.classList.add('message', side);
			
			let displayText = "";
			let displayImage = null;

			// --- LOGIQUE DE DÃ‰CHIFFREMENT SÃ‰CURISÃ‰E ---
			if (data.isEncrypted && SECRET_KEY) {
				try {
					// A. Gestion du TEXTE (On ne dÃ©chiffre QUE s'il y a du contenu)
					if (data.text && data.text.length > 0) {
						var textBytes = CryptoJS.AES.decrypt(data.text, SECRET_KEY);
						var decryptedText = textBytes.toString(CryptoJS.enc.Utf8);
						displayText = decryptedText || "[Erreur de clÃ©]";
					}

					// B. Gestion de l'IMAGE
					if (data.image) {
						// Si c'est dÃ©jÃ  du clair (envoi local), on garde tel quel
						if (data.image.startsWith('data:image')) {
							displayImage = data.image;
						} else {
							// Sinon, c'est du chiffrÃ©, on dÃ©chiffre
							var imgBytes = CryptoJS.AES.decrypt(data.image, SECRET_KEY);
							var decryptedImg = imgBytes.toString(CryptoJS.enc.Utf8);
							displayImage = decryptedImg || null;
							
							// Si l'image dÃ©chiffrÃ©e est vide, c'est une erreur de clÃ©
							if (!displayImage) displayText = "[ClÃ© image incorrecte]";
						}
					}
				} catch (e) { 
					console.error("Erreur de dÃ©chiffrement :", e);
					displayText = "[Message illisible]"; 
				}
			} else {
				// Mode non-chiffrÃ© (historique ancien ou texte simple)
				displayText = data.text || "";
				displayImage = data.image || null;
			}

			// --- LE RESTE DU CODE (AFFICHAGE) ---
			var color = getHashColor(data.pseudo || "Anonyme");
			var nameStyle = (side === 'me') ? 'display:none' : `color:${color}; font-weight:bold; font-size:0.8em; margin-bottom:3px;`;
			var imageHtml = displayImage ? `<img src="${displayImage}" style="max-width:100%; border-radius:10px; margin-top:5px; display:block;">` : "";

			var tickContent = (data.read) ? 'âœ“âœ“' : 'âœ“';
			var tickColor = (data.read) ? 'color: #3498db;' : '';
			var statusCheckHtml = (side === 'me') ? 
				`<span class="status-check" id="tick-${data.id || Date.now()}" style="${tickColor}">${tickContent}</span>` : "";

			item.innerHTML = `
				<div style="${nameStyle}">${data.pseudo || 'Anonyme'}</div>
				<div class="message-wrapper">
					<div>${displayText}</div>
					${imageHtml}
				</div>
				<div class="message-footer" style="display: flex; align-items: center; justify-content: flex-end; gap: 4px;">
					<span class="time">${data.time || ''}</span>
					${statusCheckHtml}
				</div>
			`;

			document.getElementById('messages').appendChild(item);
			const messagesList = document.getElementById('messages');
			messagesList.scrollTop = messagesList.scrollHeight;
		}
    
        // --- 4. ENVOI DE TEXTE ---
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          if (input.value.trim()) {
            var timeStr = getNowFormatted(); // Utilisation du nouveau format
            
            var encryptedText = CryptoJS.AES.encrypt(input.value, SECRET_KEY).toString();
            var data = { text: encryptedText, time: timeStr, pseudo: myPseudo, isEncrypted: true, id: 'msg-' + Date.now() };
            
            addMessage(data, 'me');
            socket.emit('chat message', data);
            input.value = '';
            input.style.height = 'auto';
            socket.emit('stop typing');
          }
        });
    
        // --- 5. IHM : ENTRÃ‰E ET AGRANDISSEMENT AUTO ---
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            form.dispatchEvent(new Event('submit'));
          }
        });
    
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
            socket.emit('typing', myPseudo);
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => socket.emit('stop typing'), 5000);
        });
    
        // --- 6. ENVOI DE PHOTOS CHIFFRÃ‰ES ---
		document.getElementById('file-input').addEventListener('change', function(e) {
			const file = e.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = function(event) {
				const rawImageData = event.target.result; // C'est le Base64 de l'image

				// 1. On chiffre l'image avec la clÃ© AES
				// On utilise la mÃªme fonction encrypt que pour tes messages texte
				const encryptedImage = CryptoJS.AES.encrypt(rawImageData, SECRET_KEY).toString();;

				const imageData = {
					id: 'img-' + Date.now(),
					text: "", 
					image: encryptedImage,    // On envoie la version CHIFFRÃ‰E
					isEncrypted: true,        // On passe Ã  TRUE
					time: getNowFormatted(),
					pseudo: myPseudo
				};

				// 2. On l'affiche pour SOI (en local, on peut afficher l'original pour aller plus vite)
				// Mais attention : addMessage doit savoir gÃ©rer les images chiffrÃ©es/dÃ©chiifrÃ©es
				addMessage({ ...imageData, image: rawImageData }, 'me');

				// 3. On envoie le paquet sÃ©curisÃ© au serveur
				socket.emit('chat message', imageData);
			};
			reader.readAsDataURL(file);
		});
    
        // --- 7. EMOJIS ---
        const picker = new EmojiMart.Picker({
            locale: 'fr',
            onEmojiSelect: (emoji) => {
                input.value += emoji.native;
                input.dispatchEvent(new Event('input')); 
                input.focus();
                picker.style.display = 'none';
            }
        });
        picker.style.display = 'none';
        picker.style.position = 'absolute';
        picker.style.bottom = '80px';
        picker.style.left = '10px';
        picker.style.zIndex = '1000';
        document.body.appendChild(picker);
    
        document.getElementById('emoji-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            picker.style.display = (picker.style.display === 'none') ? 'block' : 'none';
        });
    
        document.addEventListener('click', (e) => {
            if (!picker.contains(e.target) && e.target.id !== 'emoji-btn') picker.style.display = 'none';
        });
    
        // --- 8. SOCKETS ---
		function setupSocketListeners() {
			// On vÃ©rifie que le socket existe bien
			if (!socket) return;
				
			socket.on('load history', (h) => {
			  messages.innerHTML = '';
			  h.forEach(m => {addMessage(m, m.pseudo === myPseudo ? 'me' : 'them');
				// Si le message vient de quelqu'un d'autre, on confirme la lecture
				if (m.pseudo !== myPseudo && m.id) {
					socket.emit('message read', m.id);
					}
				});
			});
				
			socket.on('chat message', function(data) {
				// On s'assure que data est un objet
				let msgData = (typeof data === 'object') ? data : { text: data, pseudo: 'Anonyme', time: getNowFormatted(), id: Date.now() };
		
				// CORRECTION : On utilise myPseudo (ta variable globale)
				if (msgData.pseudo !== myPseudo) { 
					console.log("RÃ©ception d'un message de : " + msgData.pseudo);
					addMessage(msgData, 'them');
					
					// On informe le serveur qu'on a lu le message
					if (msgData.id) {
						socket.emit('message read', msgData.id);
					}
				}
			});
				
			socket.on('user typing', (pseudo) => {
				const lang = localStorage.getItem('preferred-lang') || 'fr';
				// On vÃ©rifie que translations existe avant d'afficher
				if (typeof translations !== 'undefined' && translations[lang]) {
					typingIndicator.textContent = pseudo + translations[lang].typing;
				}
			});
			
			socket.on('user stop typing', () => { typingIndicator.textContent = ""; });
		
			socket.on('user read message', (msgId) => {
				const tick = document.getElementById(`tick-${msgId}`);
				if (tick) {
					tick.innerText = 'âœ“âœ“'; // Passage au double check
					tick.style.color = '#3498db'; // Passage au bleu
				}
			});
			
			socket.on('update users timezones', (allTZ) => {
				// On cherche le fuseau de la personne qui n'est pas "Moi"
				for (let user in allTZ) {
					if (user !== myPseudo) {
						themTZ = allTZ[user];
					}
				}
			});
		}
        
    	
    
        function getHashColor(str) {
          if(!str) return '#000';
          var hash = 0; for (var i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
          var c = '#'; for (var i = 0; i < 3; i++) c += ('00' + ((hash >> (i * 8)) & 0xFF).toString(16)).slice(-2);
          return c;
        }
    	
    	// Fonction pour appliquer la langue	
    	function applyLanguage(lang) {
    		console.log("Changement de langue vers :", lang); // Pour vÃ©rifier dans la console (F12)
    		
    		const t = translations[lang];
    		if (!t) {
    			console.error("Langue non trouvÃ©e dans translations.js :", lang);
    			return;
    		}
    
    		// Liste des IDs Ã  mettre Ã  jour
    		const mapping = {
    			'txt-header-title': t.header_title,
    			'txt-view-cgu': t.view_cgu,
				'txt-welcome-title': t.welcome_title, // NOUVEAU
				'enter-chat-btn': t.enter_chat,      // NOUVEAU
				'quote-intro': t.quote_intro,        // NOUVEAU (si tu ajoutes ce span)
    			'input': 'placeholder' // Cas spÃ©cial pour le placeholder
    		};
    
    		for (let id in mapping) {
    			const el = document.getElementById(id);
    			if (el) {
    				if (mapping[id] === 'placeholder') {
    					el.placeholder = t.input_placeholder;
    				} else {
    					el.innerText = mapping[id];
    				}
    			} else {
    				console.warn("Ã‰lÃ©ment introuvable : " + id);
    			}
    		}
			// Mettre Ã  jour la citation du jour (depuis quotes.js)
			if (typeof displayDailyQuote === 'function') {
				displayDailyQuote(lang);
			}
    
			// Sauvegarder la langue
			localStorage.setItem('preferred-lang', lang);
			
			// SYNCHRONISATION : On s'assure que les deux sÃ©lecteurs affichent la mÃªme langue
			// On cherche tous les menus de langue et on leur impose la valeur
			const selectors = ['lang-select-home', 'lang-select']; 
			selectors.forEach(id => {
				const el = document.getElementById(id);
				if (el) {
					el.value = lang; // Force l'affichage sur "en", "fr" ou "zh"
				}
			});
	
    		// Mise Ã  jour du bouton envoyer (recherche par balise si pas d'ID)
    		const sendBtn = document.querySelector('#form button:not([type="button"])');
    		if (sendBtn) sendBtn.innerText = t.send_btn;
						    		
    		// On met Ã  jour le lien vers les CGU pour inclure la langue
    		const cguLink = document.getElementById('txt-view-cgu');
    		if(cguLink) {
    			cguLink.href = `/cgu?lang=${lang}`;
    			}
    	}
    
    	// Initialisation au chargement
    	document.addEventListener('DOMContentLoaded', () => {
    		const selector = document.getElementById('lang-select');
    		if (selector) {
    			const savedLang = localStorage.getItem('preferred-lang') || 'fr';
    			selector.value = savedLang;
    			applyLanguage(savedLang);
    
    			selector.addEventListener('change', (e) => {
    				applyLanguage(e.target.value);
    			});
    		} else {
    			console.error("Le sÃ©lecteur 'lang-selector' est introuvable !");
    		}
    	});
    	
    	/* DARK MODE */
    	const themeToggle = document.getElementById('theme-toggle');
    
    	// 1. Charger le thÃ¨me sauvegardÃ©
    	const savedTheme = localStorage.getItem('theme') || 'light';
    	if (savedTheme === 'dark') {
    		document.documentElement.setAttribute('data-theme', 'dark');
    		themeToggle.innerText = 'â˜€ï¸';
    	}
    
    	// 2. Ã‰couter le clic sur le bouton
    	themeToggle.addEventListener('click', () => {
    		const isDark = document.documentElement.hasAttribute('data-theme');
    		if (isDark) {
    			document.documentElement.removeAttribute('data-theme');
    			themeToggle.innerText = 'ðŸŒ™';
    			localStorage.setItem('theme', 'light');
    		} else {
    			document.documentElement.setAttribute('data-theme', 'dark');
    			themeToggle.innerText = 'â˜€ï¸';
    			localStorage.setItem('theme', 'dark');
    		}
    	});
		
		/* Horloge */
		let themTZ = "Asia/Shanghai"; // Par dÃ©faut

		
		function updateDynamicClocks() {
			const now = new Date();

			// 1. DÃ©tection automatique de MA ville
			const myTZ = Intl.DateTimeFormat().resolvedOptions().timeZone;
			const myCity = myTZ.split('/').pop().replace('_', ' ');
			const themCity = themTZ.split('/').pop().replace('_', ' ');

			const zones = [
				{ id: 'me-analog', tz: myTZ, nameId: 'me-city-name', name: myCity },
				{ id: 'them-analog', tz: themTZ, nameId: 'them-city-name', name: themCity }
			];

			zones.forEach(zone => {
				try {
					const timeStr = now.toLocaleTimeString('en-US', { 
						timeZone: zone.tz, hour12: false, hour: '2-digit', minute: '2-digit' 
					});
					const [hours, minutes] = timeStr.split(':').map(Number);

					const hourDeg = (hours % 12) * 30 + minutes * 0.5;
					const minuteDeg = minutes * 6;

					const clockEl = document.getElementById(zone.id);
					clockEl.style.borderColor = zone.color;
					clockEl.querySelector('.hour').style.transform = `translateX(-50%) rotate(${hourDeg}deg)`;
					clockEl.querySelector('.minute').style.transform = `translateX(-50%) rotate(${minuteDeg}deg)`;
					//clockEl.querySelector('.hour').style.backgroundColor = zone.color;
					
					document.getElementById(zone.nameId).innerText = zone.name;
				} catch (e) {
					console.error("Erreur sur le fuseau :", zone.tz);
				}
			});
		}

		setInterval(updateDynamicClocks, 1000);
		updateDynamicClocks();
		
		/* PensÃ©e du jour */
		function displayDailyQuote(forcedLang) {
			// Si on passe une langue, on l'utilise, sinon on cherche dans le stockage, sinon 'fr'
			const currentLang = forcedLang || localStorage.getItem('preferred-lang') || 'fr';
			
			// On vÃ©rifie si la fonction getDailyQuote (de quotes.js) existe
			if (typeof getDailyQuote === 'function') {
				const quoteText = getDailyQuote(currentLang);
				const quoteEl = document.getElementById('quote-text');
				if (quoteEl) {
					quoteEl.innerText = quoteText;
				}
			}
		}
		
    </script>
</body>

</html>